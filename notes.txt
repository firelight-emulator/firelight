1. examining switch GUI elements

a.



2.
GET /platforms
GET /platforms/{id}
GET /platforms/{id}/input-devices

GET /input/devices
GET /input/profiles
GET /input/profiles/{id}
GET /input/mappings
GET /input/mappings/{id}

GET /library/entries
GET /library/entries/{id}

GET /library/run-configurations
GET /library/run-configurations/{id}

GET /library/rom-files
GET /library/rom-files/{id}
GET /library/patch-files

pacman -S mingw-w64-clang-x86_64-toolchain
mingw-w64-x86_64-clang-analyzer

install PIP (should come with Python)

might need to set on PATH


$ VCPKG_DEFAULT_TRIPLET=x64-mingw-static ../qt5/configure.bat -init-submodules -submodules qtbase,qtimageformats,qtshadertools,qtsvg,qtlanguageserver,qtdeclarative,qtquick3d,qtmultimedia,qtcharts,qtconnectivity,qttools,qtgraphs -skip qtxmlpatterns,qtwebview,qtwebsockets,qtserialbus,qtserialport -release -static -vcpkg -nomake tests -nomake examples -opensource

Once everything is built, you must run 'cmake --install .'
Qt will be installed into 'C:/Qt/Qt-6.9.0'

To configure and build other Qt modules, you can use the following convenience script:
        C:/Qt/Qt-6.9.0/bin/qt-configure-module.bat

If reconfiguration fails for some reason, try removing 'CMakeCache.txt' from the build directory
Alternatively, you can add the --fresh flag to your CMake flags.

C:/msys64/msys2_shell.cmd -defterm -here -no-start -mingw64 -use-full-path


'C:/msys64/mingw64/bin/cmake.exe' '-DBUILD_qtxmlpatterns=OFF' '-DBUILD_qtwebview=OFF' '-DBUILD_qtwebsockets=OFF' '-DBUILD_qtserialbus=OFF' '-DBUILD_qtserialport=OFF' '-DQT_BUILD_SUBMODULES=qtbase;qtimageformats;qtshadertools;qtsvg;qtlanguageserver;qtdeclarative;qtquicktimeline;qtquick3d;qtmultimedia;qtcharts;qtconnectivity;qtactiveqt;qttools;qtgraphs' '-DBUILD_qtbase=ON' '-DBUILD_qtimageformats=ON' '-DBUILD_qtshadertools=ON' '-DBUILD_qtsvg=ON' '-DBUILD_qtlanguageserver=ON' '-DBUILD_qtdeclarative=ON' '-DBUILD_qtquicktimeline=ON' '-DBUILD_qtquick3d=ON' '-DBUILD_qtmultimedia=ON' '-DBUILD_qtcharts=ON' '-DBUILD_qtconnectivity=ON' '-DBUILD_qtactiveqt=ON' '-DBUILD_qttools=ON' '-DBUILD_qtgraphs=ON' '-DQT_INTERNAL_CALLED_FROM_CONFIGURE:BOOL=TRUE' '-DQT_USE_VCPKG=ON' '-DBUILD_SHARED_LIBS=OFF' '-DQT_BUILD_TESTS=FALSE' '-DQT_BUILD_EXAMPLES=FALSE' '-DCMAKE_BUILD_TYPE=Release' '-G' 'Ninja' 'C:/msys64/home/alexs/git/qt5'

export PERL5LIB="/usr/share/automake-1.17"

warning: The vcpkg C:\vcpkg\vcpkg.exe is using detected vcpkg root C:\vcpkg and ignoring mismatched VCPKG_ROOT environment value C:\Program Files\Microsoft Visual Studio\2022\Community\VC\vcpkg. To suppress this message, unset the environment variable or use the --vcpkg-root command line switch.


packages can provide a cmake config file or a pkg config file most of the time... sometimes both... cmake config file works with just find_package and .pc files need pkgconfig

EmulatorItem:
        properties:
                - paused
                - loaded
                - contentHash
                - displayName
                - platformId
                - saveSlotNumber
                - audioBufferFilledPercent
                - contentAspectRatio
                - contentHeight
                - contentWidth
        methods:
                - loadGame(entryId)
                - loadGame(contentHash)
        signals:
                - gameLoadSucceeded
                - gameLoadFailed
                - readyToStart
                - rewindPointsCreated
                - suspendPointLoaded
                - suspendPointCreated




 Frontend Call Order

  1. Initial Setup (during retro_load_game)

  Core calls RETRO_ENVIRONMENT_SET_HW_RENDER:
  - Check hw_render.context_type == RETRO_HW_CONTEXT_VULKAN
  - Store hw_render.context_reset and hw_render.context_destroy callbacks
  - Note the Vulkan version in hw_render.version_major (e.g., VK_MAKE_VERSION(1, 1, 0))

  Core calls RETRO_ENVIRONMENT_SET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE:
  - Store the hw_context_negotiation struct
  - You'll use these callbacks during Vulkan initialization

  2. Create Vulkan Instance

  If core provides hw_context_negotiation.create_instance (v2):
  - Call it, let core create the instance
  - Otherwise, create instance yourself

  If core provides hw_context_negotiation.get_application_info:
  - Call it to get VkApplicationInfo* (rdp.cpp:492-495 returns one requesting Vulkan 1.1)
  - Use this in your VkInstanceCreateInfo
  - Add your required instance extensions (VK_KHR_surface, etc.)

  3. Create Vulkan Device

  Pick physical device, then:

  If core provides hw_context_negotiation.create_device (or create_device2):
  struct retro_vulkan_context context = {0};
  bool success = hw_context_negotiation.create_device(
      &context,
      your_instance,
      your_chosen_gpu,
      your_surface,  // or VK_NULL_HANDLE if no presentation
      vkGetInstanceProcAddr,
      your_required_device_extensions,  // e.g., VK_KHR_swapchain
      num_extensions,
      your_required_device_layers,
      num_layers,
      your_required_features
  );

  if (success) {
      // Core has created device and filled out context struct
      // Store these - they're now YOUR resources:
      gpu = context.gpu;
      device = context.device;
      queue = context.queue;
      queue_family_index = context.queue_family_index;
      presentation_queue = context.presentation_queue;
      presentation_queue_family_index = context.presentation_queue_family_index;
  }

  The core's parallel_create_device() (rdp.cpp:438-480):
  - Creates a Vulkan device with your extensions + its own requirements
  - Fills out the retro_vulkan_context structure
  - Releases ownership - you now own the device and must destroy it

  Otherwise: Create device yourself with standard Vulkan calls

  4. Call context_reset() Callback

  After device is ready, call the core's hw_render.context_reset callback (libretro.c:1803).

  The core will then call RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE - you must provide:

  struct retro_hw_render_interface_vulkan vulkan_iface = {
      .interface_type = RETRO_HW_RENDER_INTERFACE_VULKAN,
      .interface_version = RETRO_HW_RENDER_INTERFACE_VULKAN_VERSION,
      .handle = your_backend_handle,  // Pass to all callbacks

      .instance = your_instance,
      .gpu = your_gpu,
      .device = your_device,

      .get_device_proc_addr = vkGetDeviceProcAddr,
      .get_instance_proc_addr = vkGetInstanceProcAddr,

      .queue = your_graphics_queue,
      .queue_index = your_graphics_queue_family,

      // Function pointers:
      .set_image = frontend_set_image,
      .get_sync_index = frontend_get_sync_index,
      .get_sync_index_mask = frontend_get_sync_index_mask,
      .set_command_buffers = frontend_set_command_buffers,
      .wait_sync_index = frontend_wait_sync_index,
      .lock_queue = frontend_lock_queue,
      .unlock_queue = frontend_unlock_queue,
      .set_signal_semaphore = frontend_set_signal_semaphore,
  };

  Core stores this pointer (libretro.c:500-507, rdp.cpp:120).

  5. Each Frame (in retro_run)

  a. Call vkAcquireNextImageKHR to get swapchain image index
  b. Call core's retro_run()
  c. Core will call your set_image() with the rendered image (rdp.cpp:419):

  void frontend_set_image(void *handle,
      const struct retro_vulkan_image *image,
      uint32_t num_semaphores,
      const VkSemaphore *semaphores,
      uint32_t src_queue_family)
  {
      // Store image for this frame
      current_image = image->image_view;
      current_layout = image->image_layout;  // SHADER_READ_ONLY_OPTIMAL or GENERAL

      // If semaphores provided, wait on them before using image
      // If src_queue_family != queue_family_index, do ownership transfer

      // Store for video_refresh callback
  }

  d. Core calls retro_video_refresh_t with RETRO_HW_FRAME_BUFFER_VALID
  e. Composite the core's image onto your swapchain and present

  6. Functions You Must Implement

  get_sync_index() - Return current swapchain image index:
  uint32_t frontend_get_sync_index(void *handle) {
      return current_swapchain_index;  // From vkAcquireNextImageKHR
  }

  get_sync_index_mask() - Bitmask of valid indices:
  uint32_t frontend_get_sync_index_mask(void *handle) {
      // If you have 3 swapchain images (indices 0, 1, 2):
      return (1 << 0) | (1 << 1) | (1 << 2);  // = 0b111 = 7
  }

  wait_sync_index() - Wait for current frame's GPU work:
  void frontend_wait_sync_index(void *handle) {
      // Wait for fence associated with current sync index
      vkWaitForFences(device, 1, &fences[current_sync_index], VK_TRUE, UINT64_MAX);
  }

  lock_queue() / unlock_queue() - Thread-safe queue access:
  void frontend_lock_queue(void *handle) {
      pthread_mutex_lock(&queue_mutex);
  }

  void frontend_unlock_queue(void *handle) {
      pthread_mutex_unlock(&queue_mutex);
  }

  set_signal_semaphore() - Semaphore signaled when image reusable:
  void frontend_set_signal_semaphore(void *handle, VkSemaphore semaphore) {
      signal_semaphore = semaphore;  // Signal after presenting
  }

  set_command_buffers() (optional) - Core submits command buffers to you:
  void frontend_set_command_buffers(void *handle, uint32_t num_cmd,
                                    const VkCommandBuffer *cmd) {
      // Submit these before your own command buffers
      // Not used by parallel RDP
  }

  7. Cleanup

  When unloading:
  1. Call core's hw_render.context_destroy callback (libretro.c:1819)
    - Core calls parallel_deinit() (rdp.cpp:128-132)
  2. If core provided hw_context_negotiation.destroy_device, call it
  3. Destroy VkDevice (you own it)
  4. Destroy VkInstance (if you created it)

  Key Requirements

  - Core's rendered image must have TRANSFER_SRC and SAMPLED usage flags
  - Handle ownership transfer if src_queue_family != VK_QUEUE_FAMILY_IGNORED
  - Wait for semaphores before using core's image
  - Signal set_signal_semaphore semaphore after you're done with the image




=============================================



Here's a complete summary of what you need to implement as a frontend:

  Resources You Need

  Vulkan Core Objects

  VkInstance instance;
  VkPhysicalDevice physical_device;
  VkDevice device;
  VkQueue graphics_queue;
  uint32_t graphics_queue_family_index;

  VkSwapchainKHR swapchain;
  VkImage swapchain_images[N];  // Usually 2-3 images
  VkImageView swapchain_image_views[N];
  VkFramebuffer framebuffers[N];

  VkCommandPool command_pool;
  VkCommandBuffer command_buffers[N];  // One per swapchain image

  VkSemaphore image_available_semaphores[N];
  VkSemaphore render_finished_semaphores[N];
  VkFence in_flight_fences[N];

  VkRenderPass render_pass;
  VkPipeline graphics_pipeline;  // For fullscreen quad
  VkPipelineLayout pipeline_layout;

  VkDescriptorSetLayout descriptor_set_layout;
  VkDescriptorPool descriptor_pool;
  VkDescriptorSet descriptor_sets[N];

  VkSampler texture_sampler;

  pthread_mutex_t queue_mutex;

  Tracking Variables

  uint32_t current_frame = 0;
  uint32_t current_image_index = 0;

  // From core's set_image():
  VkImageView core_image_view;
  VkImageLayout core_image_layout;
  VkSemaphore core_signal_semaphore;

  // Stored callbacks:
  retro_hw_render_callback hw_render;
  retro_hw_render_context_negotiation_interface_vulkan hw_negotiation;

  ---
  Complete Call Sequence

  Phase 1: Initialization (One-time setup)

  // 1. Create Vulkan instance
  VkInstanceCreateInfo instance_info = {...};
  vkCreateInstance(&instance_info, NULL, &instance);

  // 2. Pick physical device
  vkEnumeratePhysicalDevices(instance, &device_count, physical_devices);
  physical_device = physical_devices[0];  // Pick one

  // 3. Find queue family (graphics + present support)
  vkGetPhysicalDeviceQueueFamilyProperties(physical_device, &count, queue_families);
  // Find index that supports VK_QUEUE_GRAPHICS_BIT and presentation
  graphics_queue_family_index = found_index;

  // 4. Let core create device (if it wants to)
  struct retro_vulkan_context context = {0};
  bool core_created = hw_negotiation.create_device(
      &context,
      instance,
      physical_device,
      surface,
      vkGetInstanceProcAddr,
      required_extensions,  // ["VK_KHR_swapchain"]
      num_extensions,
      NULL, 0,  // No layers
      &required_features
  );

  if (core_created) {
      device = context.device;
      graphics_queue = context.queue;
      graphics_queue_family_index = context.queue_family_index;
  } else {
      // Create device yourself
      VkDeviceCreateInfo device_info = {...};
      vkCreateDevice(physical_device, &device_info, NULL, &device);
      vkGetDeviceQueue(device, graphics_queue_family_index, 0, &graphics_queue);
  }

  // 5. Create swapchain
  VkSwapchainCreateInfoKHR swapchain_info = {...};
  vkCreateSwapchainKHR(device, &swapchain_info, NULL, &swapchain);
  vkGetSwapchainImagesKHR(device, swapchain, &image_count, swapchain_images);

  // 6. Create image views for swapchain images
  for (i = 0; i < image_count; i++) {
      VkImageViewCreateInfo view_info = {...};
      vkCreateImageView(device, &view_info, NULL, &swapchain_image_views[i]);
  }

  // 7. Create render pass (for drawing to swapchain)
  VkRenderPassCreateInfo render_pass_info = {...};
  vkCreateRenderPass(device, &render_pass_info, NULL, &render_pass);

  // 8. Create framebuffers (one per swapchain image)
  for (i = 0; i < image_count; i++) {
      VkFramebufferCreateInfo fb_info = {
          .renderPass = render_pass,
          .attachmentCount = 1,
          .pAttachments = &swapchain_image_views[i],
          .width = window_width,
          .height = window_height,
          .layers = 1
      };
      vkCreateFramebuffer(device, &fb_info, NULL, &framebuffers[i]);
  }

  // 9. Create descriptor set layout (for core's texture)
  VkDescriptorSetLayoutBinding binding = {
      .binding = 0,
      .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
      .descriptorCount = 1,
      .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT
  };
  VkDescriptorSetLayoutCreateInfo layout_info = {
      .bindingCount = 1,
      .pBindings = &binding
  };
  vkCreateDescriptorSetLayout(device, &layout_info, NULL, &descriptor_set_layout);

  // 10. Create graphics pipeline (fullscreen quad shader)
  // Load vertex and fragment shaders
  // Create pipeline layout with descriptor_set_layout
  vkCreateGraphicsPipelines(device, NULL, 1, &pipeline_info, NULL, &graphics_pipeline);

  // 11. Create descriptor pool and allocate sets
  VkDescriptorPoolCreateInfo pool_info = {...};
  vkCreateDescriptorPool(device, &pool_info, NULL, &descriptor_pool);
  VkDescriptorSetAllocateInfo alloc_info = {...};
  vkAllocateDescriptorSets(device, &alloc_info, descriptor_sets);

  // 12. Create sampler
  VkSamplerCreateInfo sampler_info = {
      .magFilter = VK_FILTER_LINEAR,
      .minFilter = VK_FILTER_LINEAR,
      .addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
      .addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
      .addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
  };
  vkCreateSampler(device, &sampler_info, NULL, &texture_sampler);

  // 13. Create command pool
  VkCommandPoolCreateInfo pool_info = {
      .queueFamilyIndex = graphics_queue_family_index
  };
  vkCreateCommandPool(device, &pool_info, NULL, &command_pool);

  // 14. Allocate command buffers
  VkCommandBufferAllocateInfo cmd_alloc_info = {
      .commandPool = command_pool,
      .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
      .commandBufferCount = image_count
  };
  vkAllocateCommandBuffers(device, &cmd_alloc_info, command_buffers);

  // 15. Create sync objects
  for (i = 0; i < image_count; i++) {
      VkSemaphoreCreateInfo sem_info = {...};
      vkCreateSemaphore(device, &sem_info, NULL, &image_available_semaphores[i]);
      vkCreateSemaphore(device, &sem_info, NULL, &render_finished_semaphores[i]);

      VkFenceCreateInfo fence_info = {
          .flags = VK_FENCE_CREATE_SIGNALED_BIT
      };
      vkCreateFence(device, &fence_info, NULL, &in_flight_fences[i]);
  }

  // 16. Initialize mutex
  pthread_mutex_init(&queue_mutex, NULL);

  // 17. Call core's context_reset callback
  hw_render.context_reset();
  // Core will call RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE
  // You provide the interface with your function pointers

  ---
  Phase 2: Every Frame

  void run_frame() {
      // 1. Wait for previous frame to finish
      vkWaitForFences(device, 1, &in_flight_fences[current_frame], VK_TRUE, UINT64_MAX);
      vkResetFences(device, 1, &in_flight_fences[current_frame]);

      // 2. Acquire swapchain image
      vkAcquireNextImageKHR(device, swapchain, UINT64_MAX,
                            image_available_semaphores[current_frame],
                            VK_NULL_HANDLE, &current_image_index);

      // 3. Run core (it will call set_image() with rendered frame)
      retro_run();

      // 4. Update descriptor set with core's image
      VkDescriptorImageInfo image_info = {
          .sampler = texture_sampler,
          .imageView = core_image_view,  // From set_image()
          .imageLayout = core_image_layout  // Usually SHADER_READ_ONLY_OPTIMAL
      };
      VkWriteDescriptorSet write = {
          .dstSet = descriptor_sets[current_image_index],
          .dstBinding = 0,
          .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          .descriptorCount = 1,
          .pImageInfo = &image_info
      };
      vkUpdateDescriptorSets(device, 1, &write, 0, NULL);

      // 5. Record command buffer
      VkCommandBuffer cmd = command_buffers[current_image_index];
      vkResetCommandBuffer(cmd, 0);

      VkCommandBufferBeginInfo begin_info = {...};
      vkBeginCommandBuffer(cmd, &begin_info);

      VkRenderPassBeginInfo render_pass_begin = {
          .renderPass = render_pass,
          .framebuffer = framebuffers[current_image_index],
          .renderArea = {{0, 0}, {width, height}}
      };
      vkCmdBeginRenderPass(cmd, &render_pass_begin, VK_SUBPASS_CONTENTS_INLINE);

      vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, graphics_pipeline);
      vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
                             pipeline_layout, 0, 1,
                             &descriptor_sets[current_image_index], 0, NULL);

      vkCmdDraw(cmd, 3, 1, 0, 0);  // Draw fullscreen triangle

      vkCmdEndRenderPass(cmd);
      vkEndCommandBuffer(cmd);

      // 6. Submit command buffer
      VkPipelineStageFlags wait_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
      VkSubmitInfo submit_info = {
          .waitSemaphoreCount = 1,
          .pWaitSemaphores = &image_available_semaphores[current_frame],
          .pWaitDstStageMask = &wait_stage,
          .commandBufferCount = 1,
          .pCommandBuffers = &cmd,
          .signalSemaphoreCount = 1,
          .pSignalSemaphores = &render_finished_semaphores[current_frame]
      };

      pthread_mutex_lock(&queue_mutex);
      vkQueueSubmit(graphics_queue, 1, &submit_info, in_flight_fences[current_frame]);
      pthread_mutex_unlock(&queue_mutex);

      // 7. Signal core's semaphore if requested
      if (core_signal_semaphore != VK_NULL_HANDLE) {
          VkSubmitInfo signal_submit = {
              .signalSemaphoreCount = 1,
              .pSignalSemaphores = &core_signal_semaphore
          };
          pthread_mutex_lock(&queue_mutex);
          vkQueueSubmit(graphics_queue, 1, &signal_submit, VK_NULL_HANDLE);
          pthread_mutex_unlock(&queue_mutex);
          core_signal_semaphore = VK_NULL_HANDLE;
      }

      // 8. Present
      VkPresentInfoKHR present_info = {
          .waitSemaphoreCount = 1,
          .pWaitSemaphores = &render_finished_semaphores[current_frame],
          .swapchainCount = 1,
          .pSwapchains = &swapchain,
          .pImageIndices = &current_image_index
      };
      vkQueuePresentKHR(graphics_queue, &present_info);

      current_frame = (current_frame + 1) % image_count;
  }

  ---
  Phase 3: Implement Interface Functions

  void frontend_set_image(void *handle,
      const struct retro_vulkan_image *image,
      uint32_t num_semaphores,
      const VkSemaphore *semaphores,
      uint32_t src_queue_family)
  {
      core_image_view = image->image_view;
      core_image_layout = image->image_layout;
      // Note: parallel RDP always passes num_semaphores=0
  }

  uint32_t frontend_get_sync_index(void *handle) {
      return current_image_index;
  }

  uint32_t frontend_get_sync_index_mask(void *handle) {
      uint32_t mask = 0;
      for (int i = 0; i < image_count; i++)
          mask |= (1 << i);
      return mask;
  }

  void frontend_wait_sync_index(void *handle) {
      vkWaitForFences(device, 1, &in_flight_fences[current_frame], VK_TRUE, UINT64_MAX);
  }

  void frontend_lock_queue(void *handle) {
      pthread_mutex_lock(&queue_mutex);
  }

  void frontend_unlock_queue(void *handle) {
      pthread_mutex_unlock(&queue_mutex);
  }

  void frontend_set_signal_semaphore(void *handle, VkSemaphore semaphore) {
      core_signal_semaphore = semaphore;
  }

  void frontend_set_command_buffers(void *handle, uint32_t num, const VkCommandBuffer *cmd) {
      // Optional - parallel RDP doesn't use this
  }

  ---
  Phase 4: Cleanup

  // 1. Wait for device idle
  vkDeviceWaitIdle(device);

  // 2. Call core's context_destroy
  hw_render.context_destroy();

  // 3. Destroy sync objects
  for (i = 0; i < image_count; i++) {
      vkDestroySemaphore(device, image_available_semaphores[i], NULL);
      vkDestroySemaphore(device, render_finished_semaphores[i], NULL);
      vkDestroyFence(device, in_flight_fences[i], NULL);
  }

  // 4. Destroy Vulkan resources
  vkDestroyCommandPool(device, command_pool, NULL);
  vkDestroySampler(device, texture_sampler, NULL);
  vkDestroyDescriptorPool(device, descriptor_pool, NULL);
  vkDestroyDescriptorSetLayout(device, descriptor_set_layout, NULL);
  vkDestroyPipeline(device, graphics_pipeline, NULL);
  vkDestroyPipelineLayout(device, pipeline_layout, NULL);

  for (i = 0; i < image_count; i++) {
      vkDestroyFramebuffer(device, framebuffers[i], NULL);
      vkDestroyImageView(device, swapchain_image_views[i], NULL);
  }

  vkDestroyRenderPass(device, render_pass, NULL);
  vkDestroySwapchainKHR(device, swapchain, NULL);
  vkDestroyDevice(device, NULL);
  vkDestroyInstance(instance, NULL);

  pthread_mutex_destroy(&queue_mutex);

  ---
  The Shaders You Need

  Vertex shader (fullscreen triangle):
  #version 450
  layout(location = 0) out vec2 uv;

  void main() {
      uv = vec2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
      gl_Position = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
  }

  Fragment shader (sample core's texture):
  #version 450
  layout(binding = 0) uniform sampler2D core_texture;
  layout(location = 0) in vec2 uv;
  layout(location = 0) out vec4 color;

  void main() {
      color = texture(core_texture, uv);
  }

  That's the complete implementation!


  =======================================


  ● Looking at the code, here's what parallel RDP handles vs what you (the frontend) must handle:

    What Parallel RDP Handles

    Device Creation (rdp.cpp:438-480)

    parallel_create_device() {
        // Creates VkDevice with required extensions
        // Sets up VkQueue for graphics
        // Fills out retro_vulkan_context struct
        // Then RELEASES ownership - you own the device now
    }

    All Game Rendering (rdp.cpp)

    - Creates its own command buffers
    - Creates render targets/framebuffers for N64 output
    - Processes N64 RDP commands → Vulkan commands
    - Renders the final game frame to a VkImage
    - Calls your set_image() with that image

    Internal Resource Management

    - Shaders for N64 graphics
    - Descriptor sets for rendering
    - Textures, buffers, pipelines for emulation
    - Synchronization for its own rendering

    What It Tells You

    - parallel_get_application_info() - Wants Vulkan 1.1
    - Calls your set_image() with the rendered frame (rdp.cpp:419)
    - Calls your get_sync_index() / get_sync_index_mask() to track frames

    ---
    What YOU (Frontend) Must Handle

    1. Instance Creation ❌

    vkCreateInstance()
    Parallel doesn't create the instance - you do.

    2. Physical Device Selection ❌

    vkEnumeratePhysicalDevices()
    // Pick which GPU to use

    3. Surface/Window ❌

    VkSurfaceKHR surface;
    // Platform-specific: glfwCreateWindowSurface, etc.

    4. Device Ownership After Creation ⚠️

    Parallel creates the VkDevice, but then calls release_device() (rdp.cpp:478).
    You own it and must destroy it.

    5. Swapchain ❌

    VkSwapchainKHR swapchain;
    vkCreateSwapchainKHR()
    vkGetSwapchainImagesKHR()
    // Image views, framebuffers
    Parallel has no idea about your swapchain.

    6. Presentation Pipeline ❌

    Everything to get parallel's image onto the screen:
    - Render pass (for swapchain)
    - Graphics pipeline (fullscreen quad shader)
    - Descriptor sets (to bind parallel's image as texture)
    - Sampler
    - Command buffers (to draw to swapchain)

    7. Synchronization ⚠️

    - Semaphores for swapchain (acquire/present)
    - Fences for frame-in-flight
    - The queue mutex (lock_queue/unlock_queue)
    - Calling vkAcquireNextImageKHR / vkQueuePresentKHR

    Parallel handles sync for ITS rendering, but not swapchain presentation.

    8. The Interface Functions ❌

    frontend_set_image()
    frontend_get_sync_index()  // You return YOUR swapchain index
    frontend_get_sync_index_mask()  // Based on YOUR swapchain image count
    frontend_wait_sync_index()  // Wait on YOUR fences
    frontend_lock_queue() / frontend_unlock_queue()  // YOUR mutex
    frontend_set_signal_semaphore()

    9. Frame Loop ❌

    while (running) {
        vkAcquireNextImageKHR();  // Get swapchain image
        retro_run();  // Parallel renders, calls set_image()

        // YOU: Draw parallel's image to swapchain
        vkUpdateDescriptorSets();  // Bind parallel's image
        vkBeginCommandBuffer();
        vkCmdBeginRenderPass();
        vkCmdDraw();  // Fullscreen quad
        vkCmdEndRenderPass();
        vkEndCommandBuffer();
        vkQueueSubmit();

        vkQueuePresentKHR();  // Show it
    }

    10. Cleanup ⚠️

    hw_render.context_destroy();  // Parallel cleans up its stuff
    vkDestroyDevice();  // YOU destroy device
    vkDestroyInstance();  // YOU destroy instance
    // YOU destroy all swapchain/presentation resources

    ---
    TL;DR Summary

    | Task                       | Parallel           | You                         |
    |----------------------------|--------------------|-----------------------------|
    | VkInstance                 | ❌                  | ✅                           |
    | VkPhysicalDevice selection | ❌                  | ✅                           |
    | VkDevice creation          | ✅ (but you own it) | ⚠️                          |
    | VkQueue                    | ✅ creates          | ⚠️ use & protect with mutex |
    | Window/Surface             | ❌                  | ✅                           |
    | Swapchain                  | ❌                  | ✅                           |
    | Render N64 frame           | ✅                  | ❌                           |
    | Render to swapchain        | ❌                  | ✅                           |
    | Present to screen          | ❌                  | ✅                           |
    | N64 shaders/pipelines      | ✅                  | ❌                           |
    | Presentation pipeline      | ❌                  | ✅                           |
    | Fullscreen quad shader     | ❌                  | ✅                           |
    | Sync (internal)            | ✅                  | ❌                           |
    | Sync (swapchain)           | ❌                  | ✅                           |
    | Interface functions        | ❌                  | ✅                           |

    Basically: Parallel renders the N64 game to a texture. You handle everything else - window, swapchain, and drawing that texture to screen.